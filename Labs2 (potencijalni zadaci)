Во рамките на една видео игра се чуваат податоци за кориснички профили (UserProfile) и нивните достигнувања во играта (Achievement).
Вие треба да ги дефинирате класите и функциите за коректна имплементација на системот. Не го менувајте дадениот код.


За таа цел, дефинирајте класа Achievement со приватни податочни членки:

name - име на достигнувањето (низа од знаци);
description - опис на достигнувањето (низа од знаци);
totalUserAchievements - вкупен број на достигнувања на сите кориснички профили (static int).
Дополнете ја класата со default конструктор, конструктор со аргументи и copy конструктор како и следните функции:

print - функција која ги печати името и описот на достигнувањето во нов ред;
incrementTotalUserAchievements - функција која ја зголемува вредноста на totalUserAchievements за 1.
Потребно е да работите без get/set методи.


Понатаму, дефинирајте класа UserProfile со приватни податочни членки:

name - име на профилот (низа од знаци);
achievements - низа од добиени достигнувања на корисникот за дадената игра (максимална големина е 50);
n - број на добиени достигнувања на корисникот за дадената игра (иницијално поставен на 0).
Дополнете ја класата со default конструктор и конструктор со аргумент name.
Напишете ги функциите:

print - функција која го печати името на корисникот и неговите добиени достигнувања во играта во формат даден во тест примерите.
void addAchievement(const Achievement& achievement) - функција која во низата од достигнувања achievements го додава достигнувањето achievement и ја зголемува вредноста на totalUserAchievements.
На крај, да се напише функција void showAchievementsProgress(UserProfile profiles[], int n, Achievement achievements[], int m) 
која директно пристапува до приватните членки на класите Achievement и UserProfile, 
и за секое достигнување во играта на екран ќе ги испечати името и описот на достигнувањето, 
како и процентот на корисници кои го добиле тоа достигнување.
На крај да се испечати просечниот број на добиени достигнувања со формулата totalUserAchievements * 100.0 / (n * m). Форматот на печатењето е даден во тест примерите.


For example:

Input	
Testing Achievement methods.
1
ALL USERS:
Anonymous31
2
ALL ACHIEVEMENTS:
Secret Achievement 1
"Description is hidden for this achievement."
Final boss
"Reach the final stage."
2
LIST OF NUMBERS where user [num1] has achievement [num2]:
1 1
1 2

Result
Secret Achievement 1
"Description is hidden for this achievement."
Final boss
"Reach the final stage."

Input
Testing UserProfile methods.
2
ALL USERS:
Anonymous31
UltimateGamer
2
ALL ACHIEVEMENTS:
Secret Achievement 1
"Description is hidden for this achievement."
Final boss
"Reach the final stage."
3
LIST OF NUMBERS where user [num1] has achievement [num2]:
1 1
1 2
2 2

Result
User: Anonymous31
Achievements:
Secret Achievement 1
"Description is hidden for this achievement."
Final boss
"Reach the final stage."
User: UltimateGamer
Achievements:
Final boss
"Reach the final stage."

Input
Testing showAchievementsProgress function.
2
ALL USERS:
Anonymous31
UltimateGamer
2
ALL ACHIEVEMENTS:
Secret Achievement 1
"Description is hidden for this achievement."
Final boss
"Reach the final stage."
3
LIST OF NUMBERS where user [num1] has achievement [num2]:
1 1
1 2
2 2

Result
Secret Achievement 1
"Description is hidden for this achievement."
---Percentage of users who have this achievement: 50%
Final boss
"Reach the final stage."
---Percentage of users who have this achievement: 100%
------Average completion rate of the game: 75%



DO NOT CHANGE MAIN: 

int main() {
    char testcase[100];
    cin.getline(testcase, 100);

    int n;
    cin >> n;
    cin.ignore();

    char ignore[100];
    cin.getline(ignore, 100);
    UserProfile users[100];
    for (int i = 0; i < n; ++i) {
        char name[100];
        cin >> name;
        users[i] = UserProfile(name);
    }

    int m;
    cin >> m;
    cin.ignore();

    cin.getline(ignore, 100);
    Achievement achievements[100];
    for (int i = 0; i < m; ++i) {
        char name[100], description[100];
        cin.getline(name, 100);
        cin.getline(description, 100);
        achievements[i] = Achievement(name, description);
    }

    int k;
    cin >> k;
    cin.ignore();

    cin.getline(ignore, 100);
    for (int i = 0; i < k; ++i) {
        int numUser, numAchievement;
        cin >> numUser >> numAchievement;
        numUser -= 1;
        numAchievement -= 1;
        users[numUser].addAchievement(achievements[numAchievement]);
    }

    if (testcase[8] == 'A') {
        for (int i = 0; i < m; ++i) {
            achievements[i].print();
        }
        Achievement::incrementTotal();
    } else if (testcase[8] == 'U') {
        for (int i = 0; i < n; ++i) {
            users[i].print();
        }
    } else {
        showAchievementsProgress(users, n, achievements, m);
    }

    return 0;
}





#include <iostream>
#include <cstring>
using namespace std;

class Achievement {
private:
    char name[100];
    char description[100];
    static int totalUserAchievements;

public:
    Achievement() {
        strcpy(name, "");
        strcpy(description, "");
    }

    Achievement(const char *name, const char *description) {
        strcpy(this->name, name);
        strcpy(this->description, description);
    }

    void print() const {
        cout << name << endl;
        cout << description << endl;
    }

    static void incrementTotal() {
        totalUserAchievements++;
    }

    static int getTotal() {
        return totalUserAchievements;
    }
};

int Achievement::totalUserAchievements = 0;

class UserProfile {
private:
    char name[100];
    Achievement achievements[50];
    int numAchievements;

public:
    UserProfile() {
        strcpy(name, "");
        numAchievements = 0;
    }

    UserProfile(const char *name) {
        strcpy(this->name, name);
        numAchievements = 0;
    }

    void addAchievement(const Achievement &achievement) {
        if (numAchievements < 50) {
            achievements[numAchievements++] = achievement;
            Achievement::incrementTotal();
        }
    }

    void print() const {
        cout << "User: " << name << endl;
        cout << "Achievements:" << endl;
        for (int i = 0; i < numAchievements; ++i) {
            achievements[i].print();
        }
    }
};

void showAchievementsProgress(UserProfile profiles[], int numProfiles, Achievement achievements[], int numAchievements) {
    for (int i = 0; i < numAchievements; ++i) {
        int count = 0;
        for (int j = 0; j < numProfiles; ++j) {
            for (int k = 0; k < profiles[j].numAchievements; ++k) {
                if (strcmp(profiles[j].achievements[k].name, achievements[i].name) == 0) {
                    count++;
                    break;
                }
            }
        }
        cout << achievements[i].name << endl;
        cout << achievements[i].description << endl;
        cout << "---Percentage of users who have this achievement: "
             << (count * 100.0 / numProfiles) << "%" << endl;
    }

    double averageCompletionRate = (numProfiles > 0 && numAchievements > 0) ?
                                   (Achievement::getTotal() * 100.0 / (numProfiles * numAchievements)) : 0;
    cout << "------Average completion rate of the game: " << averageCompletionRate << "%" << endl;
}

int main() {
    char testcase[100];
    cin.getline(testcase, 100);

    int n;
    cin >> n;
    cin.ignore();

    char ignore[100];
    cin.getline(ignore, 100);
    UserProfile users[100];
    for (int i = 0; i < n; ++i) {
        char name[100];
        cin >> name;
        users[i] = UserProfile(name);
    }

    int m;
    cin >> m;
    cin.ignore();

    cin.getline(ignore, 100);
    Achievement achievements[100];
    for (int i = 0; i < m; ++i) {
        char name[100], description[100];
        cin.getline(name, 100);
        cin.getline(description, 100);
        achievements[i] = Achievement(name, description);
    }

    int k;
    cin >> k;
    cin.ignore();

    cin.getline(ignore, 100);
    for (int i = 0; i < k; ++i) {
        int numUser, numAchievement;
        cin >> numUser >> numAchievement;
        numUser -= 1;
        numAchievement -= 1;
        users[numUser].addAchievement(achievements[numAchievement]);
    }

    if (testcase[8] == 'A') {
        for (int i = 0; i < m; ++i) {
            achievements[i].print();
        }
        Achievement::incrementTotal();
    } else if (testcase[8] == 'U') {
        for (int i = 0; i < n; ++i) {
            users[i].print();
        }
    } else {
        showAchievementsProgress(users, n, achievements, m);
    }

    return 0;
}


Да се дефинира класа Employee во која ќе се чуваат информации за:

name(низа од максимум 100 карактери) -име на вработениот

surname(низа од максимум 100 карактери) - презиме

salary(цел број) - колку му е платата

методи кои што класата треба да ги има:

print() 

-Принта во формат:
Employee name: 

Employee surname: 

Employee salary: 

Да се дефинира класа TechCompany во која ќе се чуваат информации за:

name(низа од максимум 100 карактери) -име на фирмата

employees(низа од вработени) 

numOfEmployees(цел број) - колку вработени има во фирмата 

методи кои што класата треба да ги има:

print() 

-Принта во формат:
Tech company name: 

Number of employees: 

 double getAverageOfEmployeeсSalary()

-Враќа средна врендност од платите на секој вработен во таа фирма


Сите променливи внатре во класите треба да бидат приватни. Соодветно во рамките на класите да се дефинираат:

конструктор (без и со параметри)

деструктор

set методи

get методи

copy constructor

Функции надвор од класата:

printCompanyWithHighestAverageSalary(TechCompany companies[], int numCompanies)

-Го враќа TechCompany објектот што има најголема средна вредност за плати на неговите вработени
printCompanyWithHighestStdSalary(TechCompany companies[], int numCompanies)

-Го враќа TechCompany објектот што има најголема стандардна девијација за плати на неговите вработени
VAR=∑for each Employee e[(e.salary−AVG)2]n−1STD=(√VAR)

-Помош: AVG е средната вредност на платите на сите вработен во таа фирма, STD е стандардна девијација, VAR  е помошна променлива. И прво квадрирајте го изразот па потоа додадете го во сумата!
isSameCompany(TechCompany company1, TechCompany company2)

-Враќа boolean вредност: две фирми се исти ако имаат исто име. Треба само да се првери дали им е исто името!
ДА НЕ СЕ МЕНУВА MAIN ФУНКЦИЈАТА.

(Привремена слика за формулите)

For example:

Input	
3
CompanyA
5
John Doe 50000
Jane Doe 70000
Bob Smith 60000
Anna Williams 80000
Michael Brown 55000
CompanyB
4
Alice Brown 80000
David Green 70000
Eve White 50000
Frank Black 65000
CompanyC
6
Laura Lee 100000
Benjamin Johnson 65000
Emma Davis 75000
Oliver Wilson 82000
Sophie Martinez 60000
William Clark 72000

Result
-->Testing get and set methods for one object and copy constructor
copy
-->Testing addEmployee function
Number of employees in copy: 6
-->Testing copy of first employee
Employee name: John
Employee surname: Doe
Employee salary: 50000
-->Testing methods
Tech company with the highest average salary: CompanyC
Tech company with the highest standard deviation for salaries: CompanyC
The tech company: CompanyC has the highest standard deviation and highest average salary


// DO NOT CHANGE main()

int main() {
    const int MAX_COMPANIES = 10;
    const int MAX_EMPLOYEES = 20;

    TechCompany companies[MAX_COMPANIES];

    int n;
    std::cin >> n;

    for (int i = 0; i < n; i++) {
        char name[100];
        std::cin >> name;

        TechCompany company(name);

        int m;
        std::cin >> m;

        for (int j = 0; j < m; j++) {
            char name[100];
            char surname[100];
            int salary;

            std::cin >> name;
            std::cin >> surname;
            std::cin >> salary;

            Employee employee(name, surname, salary);

            company.addEmployee(employee);
        }

        companies[i] = company;
    }

    TechCompany copy = companies[0];

    std::cout << "-->Testing get and set methods for one object and copy constructor" << std::endl;
    copy.setName("copy");
    std::cout << copy.getName() << std::endl;

    std::cout << "-->Testing addEmployee function" << std::endl;
    Employee newEmployee("John", "Doe", 5000);
    copy.addEmployee(newEmployee);
    std::cout << "Number of employees in copy: " << copy.getNumOfEmployees() << std::endl;

    std::cout << "-->Testing copy of first employee" << std::endl;
    Employee firstEmployee = copy.getEmployee(0);
    firstEmployee.print();

    std::cout << "-->Testing methods" << std::endl;
    TechCompany t = printCompanyWithHighestAverageSalary(companies, n);
    TechCompany t1 = printCompanyWithHighestStdSalary(companies, n);

    std::cout << "Tech company with the highest average salary: " << t.getName() << std::endl;
    std::cout << "Tech company with the highest standard deviation for salaries: " << t1.getName() << std::endl;

    if (isSameCompany(t, t1)) {
        std::cout << "The tech company: " << t.getName() << " has the highest standard deviation and highest average salary" << std::endl;
    }
    return 0;
}



#include <iostream>
#include <cstring>
#include <iomanip>
#include <cmath>
#include <string>
#include <string.h>

using namespace std;


class Employee{
private:
    char name[100];
    char surname[100];
    int salary;
public:
    Employee(char *name="lol", char *surname="lmao", int salary=0)  {
        ::strcpy(this->name, name);
        ::strcpy(this->surname,surname);
        this->salary=salary;
    }



    Employee(const Employee &e){
        ::strcpy(this->name, e.name);
        ::strcpy(this->surname,e.surname);
        this->salary=e.salary;
    }


    const char *getName() const {
        return name;
    }



    const char *getSurname() const {
        return surname;
    }

    int getSalary() const {
        return salary;
    }

    void setSalary(int salary) {
        Employee::salary = salary;
    }

    void print(){
        cout<<"Employee name: "<<name<<endl;
        cout<<"Employee surname: "<<surname<<endl;
        cout<<"Employee salary: "<<salary<<endl;
    }

    ~Employee(){}
};



class TechCompany{
private:
    char name[100];
    Employee employees[20];
    int numOfEmployees;
public:
    TechCompany(char *name="lol") {
        ::strcpy(this->name,name);
       numOfEmployees=0;
    }

    const char *getName() const {
        return name;
    }
    void setName(char *name){
        ::strcpy(this->name,name);
    }



    const Employee &getEmployee(int index) const {
        return employees[index];
    }

    int getNumOfEmployees() const {
        return numOfEmployees;
    }

    void setNumOfEmployees(int numOfEmployees) {
        TechCompany::numOfEmployees = numOfEmployees;
    }

    void addEmployee(const Employee &employee){
        if(numOfEmployees < 20){
            employees[numOfEmployees++]=employee;
        }

    }

    void print(){
        cout<<"Tech company name: "<<name<<endl;
        cout<<"Number of employees: "<<numOfEmployees<<endl;

    }


    double getAverageSalary(){
        int sum=0;
        for (int i = 0; i <numOfEmployees ; ++i) {
            sum+=employees[i].getSalary();
        }

        return sum/numOfEmployees;
    }

    double getStandardDeviationSalary() {
        double avg = getAverageSalary();
        double sum = 0;
        for (int i = 0; i < numOfEmployees; ++i) {
            sum += pow(employees[i].getSalary() - avg, 2);
        }
        return numOfEmployees > 1 ? sqrt(sum / numOfEmployees) : 0;
    }

~TechCompany(){}
};


TechCompany printCompanyWithHighestAverageSalary(TechCompany companies[], int numCompanies){

    TechCompany highest = companies[0];
    for (int i = 1; i < numCompanies; ++i) {
        if (companies[i].getAverageSalary() > highest.getAverageSalary()) {
            highest = companies[i];
        }
    }
    return highest;
}

TechCompany printCompanyWithHighestStdSalary(TechCompany companies[], int numCompanies){
    TechCompany highest = companies[0];
    for (int i = 1; i < numCompanies; ++i) {
        if (companies[i].getStandardDeviationSalary() > highest.getStandardDeviationSalary()) {
            highest = companies[i];
        }
    }
    return highest;
}

bool isSameCompany(TechCompany company1, TechCompany company2){
    return strcmp(company1.getName(),company2.getName())==0;
}

int main() {
    const int MAX_COMPANIES = 10;
    const int MAX_EMPLOYEES = 20;

    TechCompany companies[MAX_COMPANIES];

    int n;
    std::cin >> n;

    for (int i = 0; i < n; i++) {
        char name[100];
        std::cin >> name;

        TechCompany company(name);

        int m;
        std::cin >> m;

        for (int j = 0; j < m; j++) {
            char name[100];
            char surname[100];
            int salary;

            std::cin >> name;
            std::cin >> surname;
            std::cin >> salary;

            Employee employee(name, surname, salary);

            company.addEmployee(employee);
        }

        companies[i] = company;
    }

    TechCompany copy = companies[0];

    std::cout << "-->Testing get and set methods for one object and copy constructor" << std::endl;
    copy.setName("copy");
    std::cout << copy.getName() << std::endl;

    std::cout << "-->Testing addEmployee function" << std::endl;
    Employee newEmployee("John", "Doe", 5000);
    copy.addEmployee(newEmployee);
    std::cout << "Number of employees in copy: " << copy.getNumOfEmployees() << std::endl;

    std::cout << "-->Testing copy of first employee" << std::endl;
    Employee firstEmployee = copy.getEmployee(0);
    firstEmployee.print();

    std::cout << "-->Testing methods" << std::endl;
    TechCompany t = printCompanyWithHighestAverageSalary(companies, n);
    TechCompany t1 = printCompanyWithHighestStdSalary(companies, n);

    std::cout << "Tech company with the highest average salary: " << t.getName() << std::endl;
    std::cout << "Tech company with the highest standard deviation for salaries: " << t1.getName() << std::endl;

    if (isSameCompany(t, t1)) {
        std::cout << "The tech company: " << t.getName() << " has the highest standard deviation and highest average salary" << std::endl;
    }
    return 0;
}


Да се дефинира класа MobilePhone во која ќе се чуваат податоци за еден мобилен телефон:

модел (низа од карактери не подолга од 20 карактери)
број на модел (цел број)
година на издавање (цел број)
За класата да се дефинира default конструктор, конструктор со аргументи, copy конструктор, деструктор и доколку има потреба get методи. Исто така да се дефинира и фунцкија за печатење на информации за класата која ќе печати во следниот формат „(модел) (број на модел) release year: (година на издавање)“.

Потоа да се дефинира класа Owner во која се чуваат следните информации:

име (низа од карактери не подолга од 20 карактери)
презиме (низа од карактери не подолга од 20 карактери)
мобилен телефон (објект од класа MobilePhone)
Да се креира default конструктор, конструктор со аргументи, деструктор и доколку има потреба get методи. Исто така да се дефинира и функција за печатење на информации за класата која ќе печати во следниот формат: 

„(име) (презиме) has a mobile phone:

(информации за мобилен телефон)“

ДА НЕ СЕ МЕНУВА MAIN ФУНКЦИЈАТА!!!

For example:

Input	
1
Iphone
12
2020
Marko
Petrov

Result
Marko Petrov has a mobile phone:
Iphone 12 release year: 2020



//DO NOT CHANGE THE MAIN FUNCTION
int main() {
    char model[20];
    int modelNumber;
    int year;
    char name[20];
    char surname[20];

    int testCase;

    cin>>testCase;

    cin>>model;
    cin>>modelNumber;
    cin>>year;
    cin>>name;
    cin>>surname;

    if(testCase==1){
        MobilePhone mobilePhone(model,modelNumber,year);

        Owner owner(name,surname,mobilePhone);
        owner.print();
    }
    if(testCase==2){
        MobilePhone mobilePhone(MobilePhone(model,modelNumber,year));

        Owner owner(name,surname,mobilePhone);
        owner.print();
    }

}



#include <iostream>
#include <cstring>
using namespace std;

//YOUR CODE HERE

class MobilePhone {
private:
    char model[21];
    int modelNumber;
    int yearOfIssue;

public:
    //Default Constructor
    MobilePhone() {
        strcpy(model, "");
        modelNumber = 0;
        yearOfIssue = 0;
    }

    //Constructor with arguments
    MobilePhone(const char* newModel, int newModelNumber, int newYear) {
        strcpy(model, newModel);
        modelNumber = newModelNumber;
        yearOfIssue = newYear;
    }

    //Copy Constructor
    MobilePhone(const MobilePhone& other) {
        strcpy(model, other.model);
        modelNumber = other.modelNumber;
        yearOfIssue = other.yearOfIssue;
    }

    //Destructor
    ~MobilePhone() {}

    //Get methods
    const char* getModel() const {
        return model;
    }

    int getModelNumber() const {
        return modelNumber;
    }

    int getYearOfIssue() const {
        return yearOfIssue;
    }

    //Prints mobile phone information
    void print() const {
        cout << getModel() << " " << getModelNumber() << " release year: " << getYearOfIssue() << endl;
    }
};

class Owner {
private:
    char name[21];
    char lastName[21];
    MobilePhone mobilePhone;

public:
    
    Owner() {
        strcpy(name, "");
        strcpy(lastName, "");
        mobilePhone = MobilePhone();
    }

   
    Owner(const char* newName, const char* newLastName, const MobilePhone& newMobilePhone) {
        strcpy(name, newName);
        strcpy(lastName, newLastName);
        mobilePhone = newMobilePhone;
    }

    
    ~Owner() {}

    
    const char* getName() const {
        return name;
    }

    const char* getLastName() const {
        return lastName;
    }

    const MobilePhone& getMobilePhone() const {
        return mobilePhone;
    }

    
    void print() const {
        cout << getName() << " " << getLastName() << " has a mobile phone:" << endl;
        mobilePhone.print();
    }
};

//DO NOT CHANGE THE MAIN FUNCTION
int main() {
    char model[20];
    int modelNumber;
    int year;
    char name[20];
    char surname[20];

    int testCase;

    cin>>testCase;

    cin>>model;
    cin>>modelNumber;
    cin>>year;
    cin>>name;
    cin>>surname;

    if(testCase==1){
        MobilePhone mobilePhone(model,modelNumber,year);

        Owner owner(name,surname,mobilePhone);
        owner.print();
    }
    if(testCase==2){
        MobilePhone mobilePhone(MobilePhone(model,modelNumber,year));

        Owner owner(name,surname,mobilePhone);
        owner.print();
    }

}



Да се дефинира класа InvoiceItem во која што ќе се чуваат податоци за една ставка во фактура:

име на ставка (низа од максимум 100 карактери)
цена на ставка (цел број)
За класата да се дефинира copy конструктор, default конструктор и конструктор со аргументи.
Доколку е потребно да се креира и get методи.

Потоа да се креира класа Invoice во која што се чуваат следните податоци:

број на фактура (низа од максимум 10 карактери)
број на ставки во фактурата (цел број)
низа од ставки во фактурата (низа од објекти од InvoiceItem класата, max 100)
Да се креира конструктор со аргументи за класата.
Доколку е потребно да се креира и get методи.

Во класата да се креира метода totalPrice што ќе го пресметува вкупниот износ на фактурата. Вкупниот износ на фактурата се пресметува како збир од цените на сите ставки во нејзе.

ДА НЕ СЕ МЕНУВА MAIN ФУНКЦИЈАТА.

1
[12:08 PM]


#include <iostream>
#include <cstring>

using namespace std;

// Класа за една ставка во фактурата
class InvoiceItem {
private:
    char name[101];  // Име на ставката (максимум 100 знаци + '\0')
    int price;       // Цена на ставката

public:
    // Default конструктор
    InvoiceItem() {
        strcpy(name, "");
        price = 0;
    }

    // Конструктор со аргументи
    InvoiceItem(const char *name, int price) {
        strcpy(this->name, name);
        this->price = price;
    }

    // Copy конструктор
    InvoiceItem(const InvoiceItem &other) {
        strcpy(this->name, other.name);
        this->price = other.price;
    }

    // Гетери (ако се потребни)
    const char* getName() const {
        return name;
    }

    int getPrice() const {
        return price;
    }

    // Метод за печатење
    void print() const {
        cout << "Item: " << name << ", Price: " << price << endl;
    }
};

// Класа за фактура
class Invoice {
private:
    char invoiceNumber[11];   // Број на фактура (максимум 10 знаци + '\0')
    int numItems;             // Број на ставки во фактурата
    InvoiceItem items[100];   // Поле од ставки (максимум 100)

public:
    // Конструктор со аргументи
    Invoice(const char *invoiceNumber, InvoiceItem items[], int numItems) {
        strcpy(this->invoiceNumber, invoiceNumber);
        this->numItems = numItems;
        for (int i = 0; i < numItems; i++) {
            this->items[i] = items[i];  // Копирање на ставките
        }
    }

    // Метод за пресметка на вкупната цена на фактурата
    int totalPrice() const {
        int sum = 0;
        for (int i = 0; i < numItems; i++) {
            sum += items[i].getPrice();
        }
        return sum;
    }

    // Метод за печатење на фактурата
    void print() const {
        cout << "Invoice #" << invoiceNumber << endl;
        for (int i = 0; i < numItems; i++) {
            items[i].print();
        }
        cout << "Total Price: " << totalPrice() << endl;
    }
};

// MAIN ФУНКЦИЈА (НЕ ЈА МЕНУВАМЕ)
int main() {
    int n;
    cin >> n;
    InvoiceItem items[100];

    for (int i = 0; i < n; i++) {
        char name[100];
        int price;
        cin >> name >> price;
        items[i] = InvoiceItem(name, price);
    }

    char invoiceNumber[10];
    cin >> invoiceNumber;
    Invoice invoice(invoiceNumber, items, n);

    cout << "Invoice total price: " << invoice.totalPrice() << endl;
    return 0;
}



Да се дефинира класа Potpisuvac во која се чуваат информации за:

име (низа од максимум 20 знаци)
презиме (низа од максимум 20 знаци)
ЕМБГ (низа од максимум 14 знаци)
За класата да се дефинира copy конструктор, default конструктор и конструктор со аргументи.

Да се дефинира класа Dogovor, во која се чуваат информации за:

број на договор (int),
категорија на договор (низа од 50 знаци),
поле од 3 потпишувачи на договорот (објекти од класата Potpisuvac)
Во класата да се додаде метод кој ќе проверува дали постојат два исти потпишувачи (имаат ист ЕМБГ).


int main() {
    // Креирање на потпишувачи
    Potpisuvac p1("Marko", "Markovski", "1234567890123");
    Potpisuvac p2("Ana", "Anovska", "9876543210987");
    Potpisuvac p3("Marko", "Markovski", "1234567890123"); // Ист ЕМБГ со p1

    // Поле од потпишувачи
    Potpisuvac potpisuvaci[3] = {p1, p2, p3};

    // Креирање на договор
    Dogovor d(101, "Kupoprodazen dogovor", potpisuvaci);
    
    // Печатење на договорот
    d.print();

    // Проверка за дупликат потпишувачи
    if (d.hasDuplicateSigners()) {
        cout << "Ima dva isti potpisuvaci!" << endl;
    } else {
        cout << "Nema isti potpisuvaci!" << endl;
    }

    return 0;
}




#include <iostream>
#include <cstring>

using namespace std;

class Potpisuvac {
private:
    char ime[21];       // Низа со максимум 20 знаци + 1 за null terminator
    char prezime[21];   // Низа со максимум 20 знаци
    char embg[14];      // ЕМБГ има максимум 13 знаци + 1 за null terminator

public:
    // Default конструктор
    Potpisuvac() {
        strcpy(ime, "");
        strcpy(prezime, "");
        strcpy(embg, "");
    }

    // Конструктор со аргументи
    Potpisuvac(const char *ime, const char *prezime, const char *embg) {
        strcpy(this->ime, ime);
        strcpy(this->prezime, prezime);
        strcpy(this->embg, embg);
    }

    // Copy конструктор
    Potpisuvac(const Potpisuvac &other) {
        strcpy(this->ime, other.ime);
        strcpy(this->prezime, other.prezime);
        strcpy(this->embg, other.embg);
    }

    // Метод за добивање на ЕМБГ
    const char* getEmbg() const {
        return embg;
    }

    // Метод за печатење на податоците
    void print() const {
        cout << "Potpisuvac: " << ime << " " << prezime << ", EMBG: " << embg << endl;
    }
};

class Dogovor {
private:
    int brojDogovor;
    char kategorija[51];    // Низа со максимум 50 знаци + 1 за null terminator
    Potpisuvac potpisuvaci[3];  // Поле од 3 потпишувачи

public:
    // Конструктор со аргументи
    Dogovor(int brojDogovor, const char *kategorija, const Potpisuvac potpisuvaci[3]) {
        this->brojDogovor = brojDogovor;
        strcpy(this->kategorija, kategorija);
        for (int i = 0; i < 3; i++) {
            this->potpisuvaci[i] = potpisuvaci[i];
        }
    }

    // Метод кој проверува дали има два исти потпишувачи (според ЕМБГ)
    bool hasDuplicateSigners() {
        for (int i = 0; i < 2; i++) {
            for (int j = i + 1; j < 3; j++) {
                if (strcmp(potpisuvaci[i].getEmbg(), potpisuvaci[j].getEmbg()) == 0) {
                    return true; // Ако има исти ЕМБГ, враќа true
                }
            }
        }
        return false; // Ако нема дупликати
    }

    // Метод за печатење на договорот
    void print() const {
        cout << "Dogovor #" << brojDogovor << ", Kategorija: " << kategorija << endl;
        cout << "Potpisuvaci:" << endl;
        for (int i = 0; i < 3; i++) {
            potpisuvaci[i].print();
        }
    }
};

int main() {
    // Креирање на потпишувачи
    Potpisuvac p1("Marko", "Markovski", "1234567890123");
    Potpisuvac p2("Ana", "Anovska", "9876543210987");
    Potpisuvac p3("Marko", "Markovski", "1234567890123"); // Ист ЕМБГ со p1

    // Поле од потпишувачи
    Potpisuvac potpisuvaci[3] = {p1, p2, p3};

    // Креирање на договор
    Dogovor d(101, "Kupoprodazen dogovor", potpisuvaci);
    
    // Печатење на договорот
    d.print();

    // Проверка за дупликат потпишувачи
    if (d.hasDuplicateSigners()) {
        cout << "Ima dva isti potpisuvaci!" << endl;
    } else {
        cout << "Nema isti potpisuvaci!" << endl;
    }

    return 0;
}





Да се дефинира класа Flight во која што ќе се чуваат податоци за лет:

име на лет (низа од максимум 100 карактери)
полетување од (низа од максимум 50 карактери)
пристигнување во (низа од максимум 50 карактери)
цена на лет (цел број)
За класата да се дефинира copy конструктор, default конструктор и конструктор со аргументи.
Доколку е потребно да се креираат и get методи.

Потоа да се креира класа Airport во која што се чуваат следните податоци:

име на аеродром (низа од максимум 50 карактери)
број на летови на аеродромот(цел број)
низа од летови на аеродромот(низа од објекти од Flight класата, max 100)
Да се креира конструктор со аргументи за класата.
Доколку е потребно да се креира и get методи.

Во класата да се креира функција cheapestFlight што ќе го врати најевтиниот лет на аеродромот.

ДА НЕ СЕ МЕНУВА MAIN ФУНКЦИЈАТА.


#include <iostream>
#include <cstring>

using namespace std;

class Flight {
private:
    char imeLet[101];   // Flight name (max 100 characters + null terminator)
    char poletuvanjeOd[51]; // Departure location (max 50 characters + null terminator)
    char pristignuvanjeVo[51]; // Arrival location (max 50 characters + null terminator)
    int cenaLet;        // Flight price

public:
    // Default constructor
    Flight() {
        strcpy(imeLet, "");
        strcpy(poletuvanjeOd, "");
        strcpy(pristignuvanjeVo, "");
        cenaLet = 0;
    }

    // Constructor with arguments
    Flight(const char* imeLet, const char* poletuvanjeOd, const char* pristignuvanjeVo, int cenaLet) {
        strcpy(this->imeLet, imeLet);
        strcpy(this->poletuvanjeOd, poletuvanjeOd);
        strcpy(this->pristignuvanjeVo, pristignuvanjeVo);
        this->cenaLet = cenaLet;
    }

    // Copy constructor
    Flight(const Flight &other) {
        strcpy(this->imeLet, other.imeLet);
        strcpy(this->poletuvanjeOd, other.poletuvanjeOd);
        strcpy(this->pristignuvanjeVo, other.pristignuvanjeVo);
        this->cenaLet = other.cenaLet;
    }

    // Getter for flight price
    int getCenaLet() const {
        return cenaLet;
    }

    // Print function for debugging
    void print() const {
        cout << "Flight: " << imeLet << " | From: " << poletuvanjeOd << " | To: " << pristignuvanjeVo
             << " | Price: " << cenaLet << endl;
    }
};

class Airport {
private:
    char imeAerodrom[51]; // Airport name (max 50 characters + null terminator)
    int brojLetovi;       // Number of flights
    Flight letovi[100];   // Array of flights (max 100)

public:
    // Constructor with arguments
    Airport(const char* imeAerodrom, int brojLetovi, Flight letovi[]) {
        strcpy(this->imeAerodrom, imeAerodrom);
        this->brojLetovi = brojLetovi;
        for (int i = 0; i < brojLetovi; i++) {
            this->letovi[i] = letovi[i];
        }
    }

    // Function to find the cheapest flight
    Flight cheapestFlight() const {
        if (brojLetovi == 0) {
            return Flight(); // If no flights exist, return default flight
        }

        int minIndex = 0;
        for (int i = 1; i < brojLetovi; i++) {
            if (letovi[i].getCenaLet() < letovi[minIndex].getCenaLet()) {
                minIndex = i;
            }
        }

        return letovi[minIndex]; // Return the cheapest flight
    }

    // Print function for debugging
    void print() const {
        cout << "Airport: " << imeAerodrom << " | Number of Flights: " << brojLetovi << endl;
        for (int i = 0; i < brojLetovi; i++) {
            letovi[i].print();
        }
    }
};

int main() {
    // Create flight objects
    Flight f1("Flight A", "Skopje", "Berlin", 250);
    Flight f2("Flight B", "Skopje", "Paris", 180);
    Flight f3("Flight C", "Skopje", "London", 300);
    Flight f4("Flight D", "Skopje", "Rome", 150);  // Cheapest flight

    // Store flights in an array
    Flight flights[] = {f1, f2, f3, f4};

    // Create an airport with these flights
    Airport airport("Alexander the Great", 4, flights);

    // Print airport and flights
    cout << "Airport Information:\n";
    airport.print();

    // Find and print the cheapest flight
    cout << "\nCheapest Flight:\n";
    Flight cheapest = airport.cheapestFlight();
    cheapest.print();

    return 0;
}

-----------------------------------------------------------------

MOJA VARIJANTA:


#include <iostream>
#include <cstring>

using namespace std;

class Flight {
private:
    char ime[100];
    char od[50];
    char dest[50];
    int cena;
public:
    Flight(const char *ime="rofl", const char *od="lmao", const char *dest="lol", int cena=0) {
        ::strcpy(this->ime, ime);
        ::strcpy(this->od, od);
        ::strcpy(this->dest, dest);
        this->cena = cena;
    }

    Flight(const Flight &other) {
        ::strcpy(this->ime, other.ime);
        ::strcpy(this->od, other.od);
        ::strcpy(this->dest, other.dest);
        this->cena = other.cena;
    }

    const char *getIme() const { return ime; }
    const char *getOd() const { return od; }
    const char *getDest() const { return dest; }
    int getCena() const { return cena; }

    void setCena(int cena) { this->cena = cena; }

    void print() const {
        cout << "Flight: " << ime << " | From: " << od << " | To: " << dest
             << " | Price: " << cena << endl;
    }
};

class Airport {
private:
    char ime[50];
    int broj;
    Flight flights[100];
public:
    Airport(const char *ime="lol", int broj=0, Flight *flights=nullptr) {
        ::strcpy(this->ime, ime);
        this->broj = broj;

        if (flights != nullptr) {  // Check for null pointer before copying
            for (int i = 0; i < broj; ++i) {
                this->flights[i] = flights[i];
            }
        }
    }

    Flight cheapestFlight() const {
        if (broj == 0) return Flight(); // If no flights, return default Flight

        int minIndex = 0;
        for (int i = 1; i < broj; i++) {
            if (flights[i].getCena() < flights[minIndex].getCena()) {
                minIndex = i;
            }
        }
        return flights[minIndex]; // Return cheapest flight
    }

    void print() const { // Make print() const since it doesn't modify anything
        cout << "Airport: " << ime << " | Number of Flights: " << broj << endl;
        for (int i = 0; i < broj; i++) {
            flights[i].print();
        }
    }
};

int main() {
    // Create flight objects
    Flight f1("Flight A", "Skopje", "Berlin", 250);
    Flight f2("Flight B", "Skopje", "Paris", 180);
    Flight f3("Flight C", "Skopje", "London", 300);
    Flight f4("Flight D", "Skopje", "Rome", 150);  // Cheapest flight

    // Store flights in an array
    Flight flights[] = {f1, f2, f3, f4};

    // Create an airport with these flights
    Airport airport("Alexander the Great", 4, flights);

    // Print airport and flights
    cout << "Airport Information:\n";
    airport.print();

    // Find and print the cheapest flight
    cout << "\nCheapest Flight:\n";
    Flight cheapest = airport.cheapestFlight();
    cheapest.print();

    return 0;
}



Во оваа задача треба да се внесат и испечатат податоци за автомобили.

За еден автомобил (објект од класата Car) се чуваат следниве податоци:

сопственик (објект од класата Person)
датум на купување (објект од класата Date)
цена (float price), предодредена вредност 0
За класата Car потребно е да се напише метод за печатење print() и метод за добивање на цената getPrice().

Класата Date содржи три цели броеви (int year, month, day) кои претставуваат датум. За неа треба да се напише метод за печатење print(), предодреден (default) конструктор, конструктор со параметри и конструктор за копирање.

Класата Person содржи име и презиме (низи од максимум 20 знаци, со предодредени вредности not specified), предодреден конструктор, конструктор со параметри и метод за печатење print().

Методот за печатење кај класата Person изгледа вака: [name] [lastName].

Методот за печатење кај класата Date изгледа вака: [year].[month].[day].

Методот за печатење кај класата Car изгледа вака:

owner.print()

date.print()

Price: [price]

Покрај тоа, потребно е да се напише метод cheaperThan(Car* cars, int numCars, float price) кој ќе ги испечати сите објекти Car од низата cars со големина numCars чија цена е помала од price.


#include <iostream>
#include <cstring>
using namespace std;

class Date {
    int year;
    int month;
    int day;
public:
    Date(int year=1900, int month=1, int day=1) {
        this->year = year;
        this->month = month;
        this->day = day;
    }
    Date(const Date &d) {
        this->year = d.year;
        this->month = d.month;
        this->day = d.day;
    }
    void print() const {
        cout << year << "." << month << "." << day << endl;
    }
};

class Person {
    char name[20];
    char surname[20];
public:
    Person(const char* name = "not specified", const char* surname = "not specified") {
        strcpy(this->name, name);
        strcpy(this->surname, surname);
    }
    void print() const {
        cout << name << " " << surname << endl;
    }
};

class Car {
    Person p;
    Date d;
    float price;
public:
    float getPrice() const {
        return price;
    }
    Car(Person p = Person(), Date d = Date(), float price = 0) {
        this->p = p;
        this->d = d;
        this->price = price;
    }
    void print() const {
        p.print();
        d.print();
        cout << "Price: " << price << endl;
    }
};

void cheaperThan(Car *cars, int numCars, float price) {
    for (int i = 0; i < numCars; i++) {  // Поправен for-loop
        if (cars[i].getPrice() < price) {
            cars[i].print();
        }
    }
}

int main() {
    Person p1("John", "Doe");
    Person p2("Alice", "Smith");
    Person p3("Bob", "Johnson");

    Date d1(2022, 5, 10);
    Date d2(2023, 8, 15);
    Date d3(2021, 12, 3);

    Car c1(p1, d1, 25000);
    Car c2(p2, d2, 18000);
    Car c3(p3, d3, 12000); // Најевтин автомобил

    Car cars[] = {c1, c2, c3};

    cout << "Cars cheaper than 20000:\n";
    cheaperThan(cars, 3, 20000);

    return 0;
}





